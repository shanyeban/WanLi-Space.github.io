<!DOCTYPE html>
<html lang="en">
    <head prefix="og: https://ogp.me/ns#">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="color-scheme" content="light dark">
  
  <title>javadetails - Hexo</title>
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    <link rel='manifest' href='/manifest.json'>
  

  
  
  
  <meta property="og:title" content="javadetails - Hexo" />
  
  <meta property="og:type" content="article" />
  
  <meta property="og:url" content="http://example.com/2025/02/08/javadetails/index.html" />
  
  <meta property="og:image" content="/favicon.png" />
  
  <meta property="og:article:published_time" content="2025-02-08T06:47:44.911Z" />
  
  <meta property="og:article:author" content="John Doe" />
  
  

  
<link rel="stylesheet" href="/css/var.css">

  
<link rel="stylesheet" href="/css/main.css">

  
<link rel="stylesheet" href="/css/typography.css">

  
<link rel="stylesheet" href="/css/code-highlighting.css">

  
<link rel="stylesheet" href="/css/components.css">

  
<link rel="stylesheet" href="/css/nav.css">

  
<link rel="stylesheet" href="/css/paginator.css">

  
<link rel="stylesheet" href="/css/footer.css">

  
<link rel="stylesheet" href="/css/post-list.css">

  
  
<link rel="stylesheet" href="/css/rainbow-banner.css">

  
  
  
<link rel="stylesheet" href="/css/toc.css">

  
  
  
  
  
<link rel="stylesheet" href="/css/post.css">

  
  
  
  
  

  
<meta name="generator" content="Hexo 7.3.0"></head>
    <body
        data-color-scheme="auto"
        data-uppercase-categories="true"
        
        data-rainbow-banner="true"
        data-rainbow-banner-shown="auto"
        data-rainbow-banner-month="6"
        data-rainbow-banner-colors="#e50000,#ff8d00,#ffee00,#008121,#004cff,#760188"
        
        data-config-root="/"
        
        data-toc="true"
        data-toc-max-depth="2"
        
        
    >
        <nav id="theme-nav">
    <div class="inner">
        <a class="title" href="/">Blog</a>
        <div class="nav-arrow"></div>
        <div class="nav-items">
            <a class="nav-item nav-item-home" href="/">Home</a>
            
            
            <a class="nav-item" href="/archives">Archives</a>
            
            
            
            <a class="nav-item" href="/friends">Friends</a>
            
            
            
            <a class="nav-item" href="/projects">Projects</a>
            
            
            
            <a class="nav-item" href="/about">About</a>
            
            
            
            <a class="nav-item nav-item-github nav-item-icon" href="https://github.com/MrWillCom" target="_blank" aria-label="GitHub">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-codepen nav-item-icon" href="https://codepen.io/mrwillcom" target="_blank" aria-label="CodePen">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-patreon nav-item-icon" href="https://www.patreon.com/MrWillCom" target="_blank" aria-label="Patreon">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-mastodon nav-item-icon" href="https://noc.social/@MrWillCom" target="_blank" aria-label="Mastodon">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-discord nav-item-icon" href="https://discord.gg/UKuFDjcfY8" target="_blank" aria-label="Discord">&nbsp;</a>
            
            
            
            <a class="nav-item nav-item-search nav-item-icon" href="/search" target="_blank" aria-label="Search">&nbsp;</a>
            
            
        </div>
    </div>
</nav>
        
<article class="post">
    <div class="meta">
        

        
        <div class="date" id="date">
            <span>February</span>
            <span>8,</span>
            <span>2025</span>
        </div>
        

        <h1 class="title">javadetails</h1>
    </div>

    <div class="divider"></div>

    <div class="content">
        <ul>
<li><p>在计算机中数字是以二进制形式存在，十进制中的小数可能在二进制中是无限的，是约等于的，这就可能在计算中造成误差。因此，可以将除数与被除数均变成整数进行计算，或者也可以使用相应的高精度库。进行相等比较时可以通过比较差值是否小于 0.(n)01</p>
</li>
<li><p>short, byte, char 不能自动转换(Java 的规定)，但能进行计算，计算时首先转换为 int 类型，无论这三个是同类运算还是混合运算都是转换为 int</p>
</li>
<li><p>在思考能不能进行自动转换时可以将其想象二进制，像 char 是一个字节，8 个 bit，int 是 4 个字节，32 个 bit，8 位数能放进 32 位中，只需要将多余的 bit 填上 0 就行（例如 11111111-&gt; 00000000111111111, 这是一个字节放进两个字节）</p>
</li>
<li><p>取模的本质公式</p>
<blockquote>
<p>a % b &#x3D; a - a &#x2F; b * b;</p>
<p>如果 a 为小数，则 &#x3D; a-(int)a &#x2F; b * b</p>
</blockquote>
</li>
<li><p>短路与&amp;&amp;，与短路或||如果第一个条件为假后第二个条件就既不会执行也不会判断，例如 a &#x3D; 1，if（a &lt; 0&amp;&amp;++a), 此时输出 a 就是 &#x3D; 1，但如果是逻辑与&amp;此时 a &#x3D; 2，开发中一般使用短路与和短路或，效率更高</p>
</li>
<li><p>byte a &#x3D; 1; a+&#x3D; 1 等价于 a &#x3D;(byte)(a+1)</p>
</li>
<li><p>switch 只能用于 byte, short, int, char, enum, string 这六种类型</p>
</li>
<li><p>i++或者++i 在单独使用时就相当于 i &#x3D; i + 1</p>
</li>
<li><p>字符串比较不能用 &#x3D;&#x3D;，用”字符串“.equals(变量)</p>
</li>
<li><p>值传递和引用传递: 值传递就是 int num1 &#x3D; 1; int num2 &#x3D; num1; 若此时 num2 改变不会影响到 num1，是将值拷贝了一份。数组是引用传递，是将地址拷贝了一份，int arr1 [] &#x3D;{1,1,1}; int arr2 [] &#x3D; arr1 []; arr2 [0] &#x3D; 2; 此时 arr1 [0] &#x3D; 2；arr1arr2 共享了同一地址，相互影响。如果想将 arr2 的元素等于 arr1 的元素，只需创建一个 arr2 数组，遍历 arr1，将每个元素赋值给相应的 arr2 元素即可</p>
</li>
<li><p>布尔类型数组元素默认 false</p>
</li>
<li><p>方法体如果跨类调用方法，需要在方法体内创建一个对应类的对象再调用，若不是跨类则可直接调用</p>
</li>
<li><p>方法调用的形参是不会影响到实参的，main 和方法是两个独立的空间</p>
</li>
<li><p>如果对对象的存储地点不清楚了可以看看韩顺平的 210——213 课</p>
</li>
<li><p>属性和局部变量可以重名，访问时遵循就近原则</p>
</li>
<li><p>可变参数的实质是数组，可以对可变参数实施数组的操作</p>
</li>
<li><p>可以在一个构造器内通过 this(另一个构造器的所需的参数)访问另一个构造器，但这个 this 语句必须放在构造器的第一条，但成员方法中不能这么用</p>
</li>
<li><p>如果要引用两个名字相同的类，可以在其中一个类名前加上包名，另一个类在顶部引入包；</p>
</li>
<li><p>只有 Public 和默认能修饰类</p>
</li>
<li><p>![屏幕截图 2024-11-30 004044](.\javadetails.assets\屏幕截图 2024-11-30 004044.png)</p>
</li>
<li><p>定义一个数组时，自动创建的数组对象会生成一个 length 属性，所以求长度时不需要用 length(), string 也是一个对象，但创建一个 string 对象时 length()是这个对象的方法，所以如果想要求字符串的长度需要用 length()</p>
</li>
<li><p>封装通过控制用户输入(set)和对程序输出(get)的限制实现</p>
</li>
<li><h3 id="为什么-if-a"><a href="#为什么-if-a" class="headerlink" title="为什么 if (a &lt;= x &lt;= b) 不能使用？"></a>为什么 <code>if (a &lt;= x &lt;= b)</code> 不能使用？</h3><p>在 Java 中，<code>&lt;=</code> 是二元运算符，它只接受两个操作数。所以当你写 <code>a &lt;= x &lt;= b</code> 时，实际上 Java 会把它分成两个部分来解析：</p>
<ol>
<li><strong><code>a &lt;= x</code></strong>：首先，<code>a &lt;= x</code> 会被计算为一个布尔值（<code>true</code> 或 <code>false</code>）。</li>
<li><strong><code>true &lt;= b</code> 或 <code>false &lt;= b</code></strong>：然后，接下来的部分 <code>&lt;= b</code> 会尝试比较布尔值（<code>true</code> 或 <code>false</code>）和数字 <code>b</code>。这种比较是没有意义的，因为 <code>true</code> 和 <code>false</code> 是布尔值，而 <code>b</code> 是数字类型，不能直接用 <code>&lt;=</code> 来比较布尔值和数字。</li>
</ol>
</li>
<li><p>如果父类中只有一个无参构造器，则子类的每一个构造器都会默认调用这个无参构造器。若想要在子类的构造器中调用父类的其他构造器则需要在子类构造器中用 super+（对应构造器需要的参数）</p>
<h5 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h5><ul>
<li>重写要做到方法名，参数，返回类型(父类的返回类型要能兼容子类的返回类型，就像 Object 能兼容 String，因为 String 也是类，而 Object 是所有类的父类)都做到一样。<ul>
<li>重写时子类方法的权限不能小于父类但可以大于，例如父类是 protected 那子类就不能是 private，但可以是 public</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>![屏幕截图 2024-11-30 154601](.\javadetails.assets\屏幕截图 2024-11-30 154601.png)</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h6 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h6><ul>
<li><p>编译类型可以是运行类型的父类</p>
</li>
<li><p>编译类型如果是运行类型的父类，那这个所创建的对象只能调用父类的成员，因为编译器只认编译类型，不能调用子类的成员方法，但运行时会先从子类查找有没有这个成员方法，如果没有才会到父类去匹配，在子类查找时方法重写就起了作用。简单来说右边是左边的子类，因为编译类型是左边，运行类型是右边。</p>
</li>
<li><p>最终运行效果由子类决定</p>
</li>
<li><p>属性不存在重写，由编译类型决定</p>
</li>
</ul>
<h6 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h6><ul>
<li>被强制转型的对象必须是已经向上转型的，且向下转型时的编译类型需要是被向上转型的类型，例如 Animal 是 cat 的父类, Animal animal &#x3D; new Cat();(这是向上转型) Cat cat &#x3D; (Cat) animal;(此时才能进行向下转型)。简单来说你本来是什么你才能转成什么</li>
</ul>
<h6 id="动态绑定机制"><a href="#动态绑定机制" class="headerlink" title="动态绑定机制"></a>动态绑定机制</h6><ul>
<li>你运行类型是什么，那你调用的方法就会首先到你运行类型的那个类中查找，如果找不到再去找父类。注意是一直如此，意思是就算你在当前类中没找到进入了父类查找，如果父类的那个方法还调用了一个新的方法，并且此方法子类父类都有，那么这个方法还是会调用你运行类型里面的那个。但属性没有动态绑定机制，你当前在哪个类里面就调用离你最近的那个属性</li>
</ul>
<h6 id="多态参数"><a href="#多态参数" class="headerlink" title="多态参数"></a>多态参数</h6><ul>
<li>方法的形参为父类类型，实参允许为子类类型。但此时你在方法内调用此形参时只能调用父类类型具有的方法，不然编译时通过不了，若想用子类类型的方法，需要向下转型后再调用</li>
</ul>
<h6 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h6><ul>
<li>对于引用类型来说 &#x3D;&#x3D; 比较的是地址是否相等，而 equals 比的是值是否相等</li>
</ul>
<p>静态变量</p>
<ul>
<li>类变量是随着类加载而创建的，所以即使没创建对象也能直接通过类名加变量名访问</li>
<li>静态方法只能访问静态成员，且不能使用 super，this 等关键字</li>
</ul>
<p>代码块</p>
<p>![屏幕截图 2024-12-04 005209](.\javadetails.assets\屏幕截图 2024-12-04 005209.png)</p>
<ul>
<li>父静 &#x3D; 父静块 &gt; 子静 &#x3D; 子静块 &gt; 父普 &gt; 父构 &gt; 子普 &gt; 子构</li>
<li>其实普通代码块和普通属性的显示初始化都是隐藏在构造器里面的，在 super()之后，在构造体之前，按照代码书写的先后顺序来执行</li>
<li>静态代码块只能调用静态成员，普通代码块可以调用任意成员</li>
</ul>
<h6 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h6><ul>
<li>final+static 搭配使用能阻止类加载，例如在一个类中有由 static 和 final 组合修饰的一个静态属性和一个静态方法，若在 main 方法中调用这个静态属性，此时类不会被加载，static 代码块不会执行</li>
</ul>
<h6 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h6><ul>
<li>接口中的属性前省略了 public+static+final</li>
<li>接口跟类一样访问修饰符只能是 public 或者是默认</li>
<li>实现接口的类也可以访问接口中的属性，类名加属性名即可</li>
<li>接口与实现接口的类之间也具有多态的特性，例如向上&#x2F;向下转型，动态传参，多态数组等都可以像父类与子类一样实现</li>
<li>接口的属性都是静态的</li>
</ul>
<h5 id="接口多态传递"><a href="#接口多态传递" class="headerlink" title="接口多态传递"></a>接口多态传递</h5><ul>
<li>如果类实现的接口继承了另一个接口，那么这个类要实现这两个接口的所有方法</li>
</ul>
<h6 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h6><ul>
<li>内部类是编译类型的子类</li>
<li>若外部类和内部类的成员重名，内部类访问的话默认遵守就近原则，如果想访问外部类的成员，则可以使用(外部类名.this.成员)访问。</li>
<li>匿名内部类若想进行对接口的实现，只需 new+接口名(){重写方法}就行。</li>
<li>匿名内部类不仅是一个类还是一个对象</li>
</ul>
<h6 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h6><ul>
<li>枚举类不能继承，但可以实现接口</li>
</ul>
<p>有时候在 next()中输入后会残留之前的输入，在循环时不会自动清理，会导致重复循环。next.Line()可以清理输入流，所以可以在原先的 next()代码下面加上 next.Line()函数</p>
<h6 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h6><ul>
<li>子类重写父类方法时修饰符不能比父类小，方法 throws 异常必须小于父类方法的范围，比如父类方法 throwsRuntime, 重写的方法就必须为 Runtime 或者为 Runtime 的子类</li>
<li>自定义异常时最好将自己自定义的异常类继承 Runtime，使其变成运行异常。若继承 Exception，自定义的那个类就是编译异常了，要手动在方法外加上 throws，不然编译不通过，很麻烦</li>
<li><img src="/..%5Cimage%5Cimage-20241206182638225.png" alt="image-20241206182638225"></li>
</ul>
<h6 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h6><ul>
<li>自动装包和自动拆包，多看源码</li>
<li>基本数据类型和对应的包装类进行比较时会对包装类进行自动拆包</li>
</ul>
<h6 id="String"><a href="#String" class="headerlink" title="String"></a>String</h6><ul>
<li>String 类是直接指向常量池的地址，而 StringBuffer, StringBulider 都是跟正常的类一样要先在堆中创建一个对象，StringBuffer, StringBulider 的父类有一个 value 数组属性，字符串保存在数组里面。而 new 一个 String 类时会在堆中创建一个 String 对象，有个 value 属性，但是这个属性保存的是字符串在池中的地址</li>
<li>StringBulider, StringBuffer 都是直接将字符串存储在堆里面，而 String 是引用的常量池中的一个地址，并且其字符串不可变，每次更改都改变了其引用的地址。而 StringBuffer, StringBulider 的 value 属性也是存储的地址，不过这个地址是直接指向堆中的一个数组，当存储的字符串的长度超过数组的容量时，value 会指向一个更大的数组，原来数组的内容会被拷贝过去，原来的地址也会被弃用</li>
</ul>
<h6 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h6><ul>
<li><p><img src="/.%5Cjavadetails.assets%5Cimage-20241209003516959.png" alt="image-20241209003516959"></p>
</li>
<li><p>集合其实也就是封装好的一个类而已</p>
</li>
<li><p>增强 for 其底层是简化的迭代器</p>
</li>
<li><p>ArrayList 和 LinkedList 都是 List 接口的实现子类，用法都大差不差。但 ArrayList 的用的数组，LinkedList 使用的双向链表。所以 ArrayList 增删的效率低，查改的效率高，LinkedList 完全相反</p>
</li>
<li><p>set 接口实现子类的对象集合不能用索引，它是根据 hashCode 算出的值来决定分配到哪个索引下</p>
<ul>
<li>HashSet 的底层是 HashMap，底层维护的是数组+链表。先计算传进去存储的对象的 hashCode 值，然后看对应的索引是否存在对象，如果不存在，直接放入，如果存在，对两个对象进行 object 的 equals 比较，如果返回 true，不添加，返回 false，让原先对象的 next 属性指向现在要存储的对象，在索引下形成链表。当一个索引下的链表节点有 8 个时，会判断 table 表是否达到 64，若未达到，则先扩容到 64 后再生成红黑树</li>
<li>LinkedHashset 是 Hashset 的子类，底层是 LinkedHashMap(HashMap 的子类), LinkedHashMap 底层维护的数组+双向链表，加了一个元素后就让其 next 指向下一个元素，下一个元素的 prev 指向上一个元素。要注意的是这个集合元素存储的索引不是根据存储的先后顺序，还是根据 HashCode 算出来的，只是因为双向链表的存在使得元素取出来的顺序跟存进去的顺序一样</li>
</ul>
</li>
<li><p>Map 接口的实现子类 HashMap 集合要求两个形参，一个 key 一个 value，有点类似于 python 的字典。HashMap 会对 Key 的值进行 HashCode 计算来得出所放入的索引，若 Key 相同，则新的 K-V 会替换掉旧的 K-V</p>
</li>
</ul>
<p>533-553Map 逃课, 实在是听不下去了</p>
<h6 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h6><ul>
<li><p>实际的元素类型可以是指定泛型的子类</p>
</li>
<li><p>静态成员不能使用泛型</p>
</li>
<li><p>泛型只能是基本数据类型，如果定义的位置填入的是基本数据类型，会将其自动装箱</p>
</li>
<li><p>调用泛型方法时不需要显式地指定类型参数，会自动根据你填入的参数形式来判断</p>
</li>
<li><p>泛型没有继承性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();X</span><br><span class="line">List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();√</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="进程、线程、并发、并行"><a href="#进程、线程、并发、并行" class="headerlink" title="进程、线程、并发、并行"></a>进程、线程、并发、并行</h5><p>进程是正在运行的程序</p>
<p>线程由进程创建是进程的一个实体，一个进程可以有多个线程，线程也可以创造线程。进程是内存为程序运行开辟了一片空间，线程是真的在执行某项任务，例如下载。</p>
<p>并发是一个 cpu 处理多个事件，但不是同时处理，是在极短时间内来回切换，看起来就像是同时进行的。（人脑就是单核，只能一次处理一个事件，看起来同时在做两件事实际上只是来回切换速度快）</p>
<p>并行是不同的 cpu 处理不同的事件，是真的同时在进行。</p>
<h6 id="如何在程序中启用多线程"><a href="#如何在程序中启用多线程" class="headerlink" title="如何在程序中启用多线程"></a>如何在程序中启用多线程</h6><ol>
<li><p>定义一个实现了 Thread 类的类，重写其 run 方法，在 main 方法中调用类名+start(), 这时就会启用多线程了，并且这个另外的线程不会阻碍 main 这个主线程，两个线程并行。实际上 start 方法里面还有调用了 start0()这个只能由 jvm 机调用的本地方法，start0()这个方法才是真正实现多线程的关键。</p>
</li>
<li><p>如果你想创建线程的这个类已经有了父类不能再继承 Thread，那就换一种方式。使这个类实现 Runnable 接口，再创建一个 Thread 对象，将这个类的实例当做 new Thread()的形参，再用 Thread 的对象调用 start()即可</p>
</li>
</ol>
<h6 id="礼让-yield-插队-join"><a href="#礼让-yield-插队-join" class="headerlink" title="礼让 yield, 插队 join"></a>礼让 yield, 插队 join</h6><p>这两个都是 Thread 的方法，yield 礼让是把 cpu 让出来给其他线程执行，但礼让时间，礼让是否成功都是根据 cpu 基于自身状态的判断来决定的。在线程压力小时 cpu 认为自己处理得过来，很多时候用了跟没用一样</p>
<p>join 强制指定的线程先行</p>
<h6 id="守护进程，用户进程"><a href="#守护进程，用户进程" class="headerlink" title="守护进程，用户进程"></a>守护进程，用户进程</h6><h6 id="线程的-6-种状态"><a href="#线程的-6-种状态" class="headerlink" title="线程的 6 种状态"></a>线程的 6 种状态</h6><p>其中 Runnable 状态还细分为 Ready, Running，所以有人称线程有 7 种状态。Ready 与 Running 之间的相互转换由调度器决定，不受我们控制</p>
<p><img src="/.%5Cjavadetails.assets%5Cimage-20241213004556352.png" alt="image-20241213004556352"></p>
<h6 id="同步方法-synchronized"><a href="#同步方法-synchronized" class="headerlink" title="同步方法(synchronized)"></a>同步方法(synchronized)</h6><p>同步方法是由 synchronized 修饰的方法</p>
<p>锁可以是一个对象，加上 synchronized 后这个对象就只能在同一时间被一个线程访问。所以如果想实现多线程操作同一个对象，并且实现同步方法，则同步方法的锁就必须是同一个对象。</p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPractice</span>().start;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPractice</span>().start;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPractice</span>().start;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPractice</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">synchronized</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时 run 方法默认的锁就是当前对象，但是因为 new 了三个对象，所以这三个 this 都不是同一个对象，所以锁起不了作用，所以要多线程操作同一对象最好用 Runnable 实现多线程 。若用的是 Thread，只需把同步方法的锁换成一个相同的对象即可</p>
<p>当同步方法为非静态时，锁可以为 this(默认)也可以为其他对象</p>
<p>为静态时，锁为当前类本身（this.class）</p>
<p>同步代码块与非静态的同步方法同理</p>
<h5 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h5><ol>
<li>同步方法里执行到 break</li>
<li>在同步方法里执行时遇到 Error, Exception</li>
<li>调用了当前对象的 wait 方法</li>
<li>正常执行结束</li>
</ol>
<h5 id="不释放锁"><a href="#不释放锁" class="headerlink" title="不释放锁"></a>不释放锁</h5><ol>
<li>调用 Thread.sleep 或 Thread.yield</li>
<li>该线程执行同步代码块时其他线程调用该线程的 suspend 方法将该线程挂起(suspend 方法已经过时了，尽量别用)</li>
</ol>
<h5 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h5><p>Java 中目录也被当做文件</p>
<h5 id="oi-流"><a href="#oi-流" class="headerlink" title="oi 流"></a>oi 流</h5><p>流使用完成后记得及时关闭, 不然可能造成资源的浪费</p>
<p>FileWriter 使用后不关闭或刷新无法将内容写入到指定文件</p>
<p>字符流不要去操作图片音频等二进制文件</p>
<p>反序列化时要注意要与序列化顺序一致</p>
<p>序列化时不必在意目标文件格式，序列化按照自己的格式输入</p>
<p>使用 readObject 方法反序列化，如果你想使用对应对象的方法，需要向下转型，因为取出来的编译类型是 Object</p>
<p>反序列化自定义的类时，类的访问修饰符一定要是反序列化的程序能引用到的</p>
<p>用 static, transient 修饰的属性不会被序列化</p>
<p>如果需要序列化，可以在类里面添加一个 SerialVersionUID 属性，这样在你反序列化后对这个类进行修改的话就不会被当作一个全新的类，避免无法反序列化</p>
<p>因为字符流默认读取的是 utf8 编码，所以当数据源不是用 utf8 编码时会出现乱码现象，字节流可以指定读取的编码方式，创建一个指定编码方式的字节流，再将此字节流转为字符流，最后可以选择再用 BufferdReader 这样的包装流再将字符流包装(读取效率更高，也可以不用)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(),<span class="string">&quot;jbk))</span></span><br></pre></td></tr></table></figure>

<p>如果输出流这样写，那数据流存储的就是相应的编码方式</p>
<p>字节流转为字符流用 Output&#x2F;InputStreamWriter&#x2F;Reader</p>
<h6 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h6><p>可以通过反射的暴力破解利用私有构造器创建对象</p>
<p>用反射调用方法统一用 object 接收，但这只是编译类型，运行类型还是原方法的返回值类型</p>
<h5 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h5><p>.class文件里面保存的是JVM能识别的字节码，JVM执行的就是这些字节码。不同平台的机器码是不一样的，Java为了完成它“一次编译，到处运行”的理念，充当了编译器与平台之间的桥梁，JVM会将字节码逐条翻译为对应平台的机器码，并将机器码交给cpu执行，在翻译过程中如果发现某部分语句大量重复使用（即所谓“热点代码”），此时这部分字节码就会被编译成机器码，避免了重复翻译，提高了效率。</p>

    </div>

    
    <div class="about">
        <h1>About this Post</h1>
        <div class="details">
            <p>This post is written by John Doe, licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc/4.0">CC BY-NC 4.0</a>.</p>
        </div>
        
    </div>
    

    <div class="container post-prev-next">
        <a class="next"></a>
        
        <a href="/2025/02/07/hello-world/" class="prev">
            <div>
                <div class="text">
                    <p class="label">Previous</p>
                    <h3 class="title">Hello World</>
                </div>
            </div>
        </a>
        
    </div>

    
        
        
    
</article>

        <footer>
    <div class="inner">
        <div class="links">
            
            <div class="group">
                <h2 class="title">Blog</h2>
                
                <a href="/" class="item">Blog</a>
                
                <a href="/archives" class="item">Archives</a>
                
                <a href="/tags" class="item">Tags</a>
                
                <a href="/categories" class="item">Categories</a>
                
                <a href="/search" class="item">Search</a>
                
                <a href="/friends" class="item">Friends</a>
                
                <a href="/projects" class="item">Projects</a>
                
                <a href="/resume" class="item">Resume</a>
                
                <a href="/about" class="item">About</a>
                
                <a href="/atom.xml" class="item">RSS</a>
                
            </div>
            
            <div class="group">
                <h2 class="title">Projects</h2>
                
                <a target="_blank" rel="noopener" href="https://github.com/MrWillCom/rsa-cli" class="item">RSA CLI</a>
                
                <a target="_blank" rel="noopener" href="https://github.com/MrWillCom/hexo-theme-cupertino" class="item">Hexo Theme Cupertino</a>
                
                <a target="_blank" rel="noopener" href="https://github.com/MrWillCom/a-calendar" class="item">A Calendar</a>
                
                <a target="_blank" rel="noopener" href="https://github.com/MrWillCom/auto-mirroring-bucket" class="item">Auto Mirroring Bucket</a>
                
            </div>
            
            <div class="group">
                <h2 class="title">Me</h2>
                
                <a target="_blank" rel="noopener" href="https://github.com/MrWillCom" class="item">GitHub</a>
                
                <a target="_blank" rel="noopener" href="https://codepen.io/mrwillcom" class="item">CodePen</a>
                
                <a target="_blank" rel="noopener" href="https://www.patreon.com/MrWillCom" class="item">Patreon</a>
                
                <a target="_blank" rel="noopener" href="https://noc.social/@MrWillCom" class="item">Mastodon</a>
                
                <a target="_blank" rel="noopener" href="https://discord.gg/UKuFDjcfY8" class="item">Discord</a>
                
                <a href="mailto:mr.will.com@outlook.com" class="item">Email</a>
                
            </div>
            
        </div>
        <span>&copy; 2025 John Doe<br>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> </span>
        
        
            <br>
            <div class="color-scheme-toggle" role="radiogroup" id="theme-color-scheme-toggle">
                <label>
                    <input type="radio" value="light">
                    <span>Light</span>
                </label>
                <label>
                    <input type="radio" value="dark">
                    <span>Dark</span>
                </label>
                <label>
                    <input type="radio" value="auto">
                    <span>Auto</span>
                </label>
            </div>
        
    </div>
</footer>


        
<script src="/js/main.js"></script>

        
        
        

        
        <script src="https://unpkg.com/scrollreveal"></script>
        <script>
            window.addEventListener('load', () => {
                ScrollReveal({ delay: 250, reset: true, easing: 'cubic-bezier(0, 0, 0, 1)' })
                ScrollReveal().reveal('.post-list-item .cover-img img')
                ScrollReveal().reveal('.post-list-item, .card, .content p img, .content .block-large img', { distance: '60px', origin: 'bottom', duration: 800 })
            })
        </script>
        
    </body>
</html>